{"version":3,"file":"VaAffix-utils.js","sources":["../../../../src/components/va-affix/VaAffix-utils.ts"],"sourcesContent":["import { throttle } from 'lodash-es'\nimport { Vue } from 'vue-class-component'\n\nexport type State = {\n  isTopAffixed: boolean;\n  isBottomAffixed: boolean;\n  width?: number;\n}\n\ntype Coordinates = {\n  top: number;\n  bottom: number;\n}\n\ntype ValuesToComputeAffixedState = {\n  coordinates: Coordinates;\n  offsetTop?: number;\n  offsetBottom?: number;\n  target: HTMLElement | Window | undefined;\n}\n\nexport function getWindowHeight () {\n  return document.documentElement.clientHeight ||\n    window.innerHeight ||\n    document.body.clientHeight\n}\n\nexport function computeAffixedState ({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target,\n}: ValuesToComputeAffixedState): State {\n  let isTopAffixed = false\n  let isBottomAffixed = false\n\n  const windowHeight = getWindowHeight()\n\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop\n    } else {\n      const { top } = (target as HTMLElement).getBoundingClientRect()\n      isTopAffixed = coordinates.top - top <= offsetTop\n    }\n  }\n\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom\n    } else {\n      const { bottom } = (target as HTMLElement).getBoundingClientRect()\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom\n    }\n  }\n\n  return {\n    isTopAffixed,\n    isBottomAffixed,\n  }\n}\n\nfunction checkAffixedStateChange (currentState: State, nextState: State): boolean {\n  return currentState.isTopAffixed !== nextState.isTopAffixed ||\n    currentState.isBottomAffixed !== nextState.isBottomAffixed\n}\n\nexport type Context = {\n  offsetTop?: number;\n  offsetBottom?: number;\n  element: Vue | Element | Vue[] | Element[];\n  target: HTMLElement | Window | undefined;\n  setState: (state: State) => void;\n  getState: () => State;\n  initialPosition?: ClientRect;\n}\n\nexport function handleThrottledEvent (eventName: string | null, context: Context) {\n  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context\n\n  let nextState\n\n  const isInitialCall = !eventName\n\n  // Fixme: getBoundingClientRect should always exist on element\n  const coordinates = (element as HTMLElement).getBoundingClientRect()\n\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target,\n  }\n\n  if (isInitialCall && initialPosition) {\n    nextState = computeAffixedState({ coordinates: initialPosition, ...options })\n  } else {\n    nextState = computeAffixedState({ coordinates, ...options })\n  }\n\n  const prevState = getState()\n\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({ ...nextState, width: coordinates.width })\n  } else if (prevState.width !== coordinates.width) {\n    setState({ ...prevState, width: coordinates.width })\n  }\n}\n\nfunction useCaptureDefault (eventName: string) {\n  // This event type must bubble to the Window object only when dispatched on the Document element\n  // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll\n  return eventName === 'scroll'\n}\n\ntype Options = {\n  handler: (eventName: string, event: Event) => void;\n  useCapture?: (eventName: string) => boolean;\n  wait?: number;\n}\n\nexport function useEventsHandlerWithThrottle (events: string[], {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50,\n}: Options) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle((event: Event) => handler(eventName, event), wait)\n\n    window.addEventListener(eventName, _handler, useCapture(eventName))\n\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName))\n  })\n\n  return () => clearHandlersArray.forEach(clear => clear())\n}\n"],"names":["getWindowHeight","document","documentElement","clientHeight","window","innerHeight","body","computeAffixedState","coordinates","offsetTop","offsetBottom","target","isTopAffixed","isBottomAffixed","windowHeight","top","getBoundingClientRect","bottom","handleThrottledEvent","eventName","context","element","setState","getState","initialPosition","nextState","isInitialCall","options","prevState","currentState","checkAffixedStateChange","width","useCaptureDefault","useEventsHandlerWithThrottle","events","handler","useCapture","wait","clearHandlersArray","map","_handler","throttle","event","addEventListener","removeEventListener","forEach","clear"],"mappings":"8CAqBgBA,IACd,OAAOC,SAASC,gBAAgBC,cAC9BC,OAAOC,aACPJ,SAASK,KAAKH,sBAGFI,GAAqBC,YACnCA,EAAWC,UACXA,EAASC,aACTA,EAAYC,OACZA,IAEA,IAAIC,GAAe,EACfC,GAAkB,EAEtB,MAAMC,EAAed,IAErB,GAAiB,MAAbS,GAAqBK,EACvB,GAAIH,IAAWP,OACbQ,EAAeJ,EAAYO,KAAON,MAC7B,CACL,MAAMM,IAAEA,GAASJ,EAAuBK,wBACxCJ,EAAeJ,EAAYO,IAAMA,GAAON,EAI5C,GAAoB,MAAhBC,GAAwBI,EAC1B,GAAIH,IAAWP,OACbS,EAAkBL,EAAYS,QAAUH,EAAeJ,MAClD,CACL,MAAMO,OAAEA,GAAYN,EAAuBK,wBAC3CH,EAAkBI,EAAST,EAAYS,QAAUP,EAIrD,MAAO,CACLE,aAAAA,EACAC,gBAAAA,YAmBYK,EAAsBC,EAA0BC,GAC9D,MAAMT,OAAEA,EAAMU,QAAEA,EAAOZ,UAAEA,EAASC,aAAEA,EAAYY,SAAEA,EAAQC,SAAEA,EAAQC,gBAAEA,GAAoBJ,EAE1F,IAAIK,EAEJ,MAAMC,GAAiBP,EAGjBX,EAAea,EAAwBL,wBAEvCW,EAAU,CACdjB,aAAAA,EACAD,UAAAA,EACAE,OAAAA,GAIAc,EAAYlB,EADVmB,GAAiBF,EACa,CAAEhB,YAAagB,KAAoBG,GAEnC,CAAEnB,YAAAA,KAAgBmB,IAGpD,MAAMC,EAAYL,KArCpB,SAAkCM,EAAqBJ,GACrD,OAAOI,EAAajB,eAAiBa,EAAUb,cAC7CiB,EAAahB,kBAAoBY,EAAUZ,gBAqCzCiB,CAAwBF,EAAWH,GAE5BG,EAAUG,QAAUvB,EAAYuB,OACzCT,EAAS,IAAKM,EAAWG,MAAOvB,EAAYuB,QAF5CT,EAAS,IAAKG,EAAWM,MAAOvB,EAAYuB,QAMhD,SAASC,EAAmBb,GAG1B,MAAqB,WAAdA,WASOc,EAA8BC,GAAkBC,QAC9DA,EAAOC,WACPA,EAAaJ,EAAiBK,KAC9BA,EAAO,KAEP,MAAMC,EAAqBJ,EAAOK,KAAIpB,IACpC,MAAMqB,EAAWC,GAAUC,GAAiBP,EAAQhB,EAAWuB,IAAQL,GAIvE,OAFAjC,OAAOuC,iBAAiBxB,EAAWqB,EAAUJ,EAAWjB,IAEjD,IAAMf,OAAOwC,oBAAoBzB,EAAWqB,EAAUJ,EAAWjB,OAG1E,MAAO,IAAMmB,EAAmBO,SAAQC,GAASA"}