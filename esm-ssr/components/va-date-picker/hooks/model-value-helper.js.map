{"version":3,"file":"model-value-helper.js","sources":["../../../../../src/components/va-date-picker/hooks/model-value-helper.ts"],"sourcesContent":["import { VaDatePickerModelValue, VaDatePickerModelValuePeriod, VaDatePickerMode } from '../types/types'\n\nexport const isRange = (value: VaDatePickerModelValue): value is VaDatePickerModelValuePeriod => {\n  return typeof (value as any).start !== 'undefined' && typeof (value as any).end !== 'undefined'\n}\nexport const isSingleDate = (value: VaDatePickerModelValue): value is Date => value instanceof Date\nexport const isDates = (value: VaDatePickerModelValue): value is Date[] => Array.isArray(value)\n\nconst modeInitialValue = (date: Date, mode: VaDatePickerMode) => {\n  if (mode === 'single') {\n    return date\n  } else if (mode === 'range') {\n    return { start: date, end: null }\n  } else if (mode === 'multiple') {\n    return [date]\n  } else if (mode === 'auto') {\n    return date\n  }\n\n  throw new Error('Unknown mode')\n}\n\nconst throwIncorrectModelValueError = (modelValue: VaDatePickerModelValue, mode: VaDatePickerMode) : never => {\n  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`)\n}\n\nconst modeFromModelValue = (modelValue: VaDatePickerModelValue): VaDatePickerMode => {\n  if (isSingleDate(modelValue)) {\n    return 'single'\n  } else if (isRange(modelValue)) {\n    return 'range'\n  } else if (isDates(modelValue)) {\n    return 'multiple'\n  }\n\n  return throwIncorrectModelValueError(modelValue, 'auto')\n}\n\nconst sortRange = (modelValue: VaDatePickerModelValuePeriod) => {\n  if (modelValue.start && modelValue.end) {\n    if (modelValue.start > modelValue.end) {\n      return { start: modelValue.end, end: modelValue.start }\n    }\n  }\n\n  return modelValue\n}\n\nexport const useDatePickerModelValue = (\n  props: {\n    [key: string]: any,\n    modelValue?: VaDatePickerModelValue,\n    mode: VaDatePickerMode\n  },\n  emit: (event: 'update:modelValue', newValue: VaDatePickerModelValue) => any,\n  dateEqual: (date1: Date | null, date2: Date | null) => boolean,\n) => {\n  const updateModelValue = (date: Date) => {\n    if (!props.modelValue) {\n      emit('update:modelValue', modeInitialValue(date, props.mode))\n      return\n    }\n\n    const mode = props.mode === 'auto' ? modeFromModelValue(props.modelValue) : props.mode\n\n    if (mode === 'single') {\n      if (!isSingleDate(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode)\n      }\n\n      emit('update:modelValue', date)\n    } else if (mode === 'range') {\n      if (!isRange(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode)\n      }\n\n      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {\n        return emit('update:modelValue', { start: props.modelValue.start, end: null })\n      }\n      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {\n        return emit('update:modelValue', { start: null, end: props.modelValue.end })\n      }\n\n      if (props.modelValue.end === null) {\n        return emit('update:modelValue', sortRange({ start: props.modelValue.start, end: date }))\n      }\n      if (props.modelValue.start === null) {\n        return emit('update:modelValue', sortRange({ end: props.modelValue.end, start: date }))\n      }\n\n      emit('update:modelValue', { start: date, end: null })\n    } else if (mode === 'multiple') {\n      if (!isDates(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode)\n      }\n\n      const isDatesIncludesDate = !!props.modelValue.find((d) => dateEqual(d, date))\n\n      if (isDatesIncludesDate) {\n        emit('update:modelValue', props.modelValue.filter((d) => !dateEqual(d, date)))\n      } else {\n        emit('update:modelValue', [...props.modelValue, date].sort((a, b) => a.getTime() - b.getTime()))\n      }\n    }\n  }\n\n  return {\n    updateModelValue,\n  }\n}\n"],"names":["isRange","value","start","end","isSingleDate","Date","isDates","Array","isArray","throwIncorrectModelValueError","modelValue","mode","Error","JSON","stringify","sortRange","useDatePickerModelValue","props","emit","dateEqual","updateModelValue","date","modeInitialValue","isDatesIncludesDate","find","d","filter","sort","a","b","getTime"],"mappings":"MAEaA,EAAWC,QACiB,IAAxBA,EAAcC,YAAuD,IAAtBD,EAAcE,IAEjEC,EAAgBH,GAAiDA,aAAiBI,KAClFC,EAAWL,GAAmDM,MAAMC,QAAQP,GAgBnFQ,EAAgC,CAACC,EAAoCC,KACzE,MAAMC,MAAM,iCAAiCD,UAAaE,KAAKC,UAAUJ,OAerEK,EAAaL,GACbA,EAAWR,OAASQ,EAAWP,KAC7BO,EAAWR,MAAQQ,EAAWP,IACzB,CAAED,MAAOQ,EAAWP,IAAKA,IAAKO,EAAWR,OAI7CQ,EAGIM,EAA0B,CACrCC,EAKAC,EACAC,KAmDO,CACLC,iBAlDwBC,IACxB,IAAKJ,EAAMP,WAET,YADAQ,EAAK,oBAnDc,EAACG,EAAYV,KACpC,GAAa,WAATA,EACF,OAAOU,EACF,GAAa,UAATV,EACT,MAAO,CAAET,MAAOmB,EAAMlB,IAAK,MACtB,GAAa,aAATQ,EACT,MAAO,CAACU,GACH,GAAa,SAATV,EACT,OAAOU,EAGT,MAAM,IAAIT,MAAM,iBAwCcU,CAAiBD,EAAMJ,EAAMN,OAIzD,MAAMA,EAAsB,SAAfM,EAAMN,MArCKD,EAqCgCO,EAAMP,WApC5DN,EAAaM,GACR,SACEV,EAAQU,GACV,QACEJ,EAAQI,GACV,WAGFD,EAA8BC,EAAY,SA4B6BO,EAAMN,KArC3D,IAACD,EAuCxB,GAAa,WAATC,EAAmB,CACrB,IAAKP,EAAaa,EAAMP,YACtB,OAAOD,EAA8BQ,EAAMP,WAAYC,GAGzDO,EAAK,oBAAqBG,QACrB,GAAa,UAATV,EAAkB,CAC3B,IAAKX,EAAQiB,EAAMP,YACjB,OAAOD,EAA8BQ,EAAMP,WAAYC,GAGzD,GAAIM,EAAMP,WAAWP,KAAOgB,EAAUF,EAAMP,WAAWP,IAAKkB,GAC1D,OAAOH,EAAK,oBAAqB,CAAEhB,MAAOe,EAAMP,WAAWR,MAAOC,IAAK,OAEzE,GAAIc,EAAMP,WAAWR,OAASiB,EAAUF,EAAMP,WAAWR,MAAOmB,GAC9D,OAAOH,EAAK,oBAAqB,CAAEhB,MAAO,KAAMC,IAAKc,EAAMP,WAAWP,MAGxE,GAA6B,OAAzBc,EAAMP,WAAWP,IACnB,OAAOe,EAAK,oBAAqBH,EAAU,CAAEb,MAAOe,EAAMP,WAAWR,MAAOC,IAAKkB,KAEnF,GAA+B,OAA3BJ,EAAMP,WAAWR,MACnB,OAAOgB,EAAK,oBAAqBH,EAAU,CAAEZ,IAAKc,EAAMP,WAAWP,IAAKD,MAAOmB,KAGjFH,EAAK,oBAAqB,CAAEhB,MAAOmB,EAAMlB,IAAK,YACzC,GAAa,aAATQ,EAAqB,CAC9B,IAAKL,EAAQW,EAAMP,YACjB,OAAOD,EAA8BQ,EAAMP,WAAYC,GAGzD,MAAMY,IAAwBN,EAAMP,WAAWc,MAAMC,GAAMN,EAAUM,EAAGJ,KAGtEH,EAAK,oBADHK,EACwBN,EAAMP,WAAWgB,QAAQD,IAAON,EAAUM,EAAGJ,KAE7C,IAAIJ,EAAMP,WAAYW,GAAMM,MAAK,CAACC,EAAGC,IAAMD,EAAEE,UAAYD,EAAEC"}