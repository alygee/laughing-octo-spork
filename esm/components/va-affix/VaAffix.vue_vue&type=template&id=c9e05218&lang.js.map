{"version":3,"file":"VaAffix.vue_vue&type=template&id=c9e05218&lang.js","sources":["../../../../src/components/va-affix/VaAffix.vue?vue&type=template&id=c9e05218&lang.js"],"sourcesContent":["<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { noop } from 'lodash-es'\nimport { Options, prop, mixins, Vue } from 'vue-class-component'\n\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State, Context,\n} from './VaAffix-utils'\n\nclass AffixProps {\n  offsetTop = prop<number>({ type: Number, default: undefined })\n  offsetBottom = prop<number>({ type: Number, default: undefined })\n  target = prop({ type: Function, default: () => () => window })\n}\n\nconst AffixPropsMixin = Vue.with(AffixProps)\n\n@Options({\n  name: 'VaAffix',\n  emits: ['change'],\n})\nexport default class VaAffix extends mixins(\n  AffixPropsMixin,\n) {\n  private state: State = {\n    isTopAffixed: false,\n    isBottomAffixed: false,\n  }\n\n  private initialPosition?: undefined | DOMRect\n  private clearEventListeners = noop\n\n  get computedClass () {\n    return [\n      {\n        'va-affix--affixed': this.isAffixed,\n      },\n    ]\n  }\n\n  getTargetElement () {\n    // a custom target may get rendered later than\n    // a component gets a property from the context\n    const { target } = this\n    return target()\n  }\n\n  get computedStyle () {\n    const calculateTop = () => {\n      const target = this.getTargetElement()\n\n      if (this.offsetTop === undefined) {\n        return\n      }\n\n      if (target !== window) {\n        const { top } = (target as HTMLElement).getBoundingClientRect()\n        return top + this.offsetTop\n      }\n\n      return this.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = this.getTargetElement()\n      if (this.offsetBottom === undefined) {\n        return\n      }\n\n      if (target !== window) {\n        const { bottom } = (target as HTMLElement).getBoundingClientRect()\n        const { offsetHeight, clientHeight } = (target as HTMLElement)\n        const scrollBarHeight = offsetHeight - clientHeight\n        const windowHeight = getWindowHeight()\n        return windowHeight - (bottom - this.offsetBottom) + scrollBarHeight\n      }\n\n      return this.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n\n      if (result === undefined) {\n        return\n      }\n\n      return `${result}px`\n    }\n\n    return {\n      top: this.state.isTopAffixed ? convertToPixels(calculateTop) : null,\n      bottom: this.state.isBottomAffixed ? convertToPixels(calculateBottom) : null,\n      width: `${this.state.width}px`,\n    }\n  }\n\n  get isAffixed (): boolean {\n    return this.state.isTopAffixed || this.state.isBottomAffixed\n  }\n\n  handleThrottledEvent (eventName: string | null, event?: Event) {\n    const context: Context = {\n      ...this.$data,\n      ...this.$props,\n      element: this.$refs.element as any,\n      target: this.getTargetElement(),\n      setState: this.setState.bind(this),\n      getState: this.getState.bind(this),\n    }\n\n    if (!eventName || eventName === 'resize') {\n      handleThrottledEvent(eventName, context)\n    } else if (event && event.target) {\n      const target = this.getTargetElement()\n\n      if ((target as HTMLElement) === event.target || target === window) {\n        handleThrottledEvent(eventName, context)\n      } else {\n        // if we have a custom target but keep scrolling on another element,\n        // so just disable the affixed state\n        this.setState({\n          isBottomAffixed: false,\n          isTopAffixed: false,\n        })\n      }\n    }\n  }\n\n  setState (state: State) {\n    this.state = state\n    this.$emit('change', this.isAffixed)\n  }\n\n  getState () {\n    return this.state\n  }\n\n  mounted () {\n    const events = ['scroll', 'resize']\n\n    this.initialPosition = (this.$refs.element as HTMLElement).getBoundingClientRect()\n\n    this.clearEventListeners = useEventsHandlerWithThrottle(events, {\n      handler: this.handleThrottledEvent,\n    })\n\n    this.$nextTick(() => {\n      // pass `null` here to make sure it is an initial call\n      this.handleThrottledEvent(null)\n    })\n  }\n\n  beforeUnmount () {\n    this.clearEventListeners()\n  }\n}\n</script>\n\n<style lang=\"scss\">\n@import '../../styles/resources/resources';\n@import 'variables';\n\n.va-affix {\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-zindex);\n  }\n}\n</style>\n"],"names":["ref","class","_createBlock","_hoisted_1","_createVNode","style","_ctx","_renderSlot"],"mappings":"mHAEIA,IAAI,UACJC,MAAM,uCAFRC,QAAAC,GAIEC,SAAMC,kBAAqBC,kCACzBC,0BAGMD,EAAS,eADjBJ,eAEGD,MAAOK,gBACPD,MAAOC,kBAERC"}